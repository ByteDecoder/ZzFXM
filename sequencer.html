<title>ZzFXM Song Composer</title>
<!--

ZzFXM Song Composer
By Frank Force 2020

Demo Song by Unknown Author, Remasterd by Keith Clark

todo
- better format song on save to save space
  - remove 0 before 0.
  - replace 0 with undefined where possible
- visualizer
- light up instruments when played
- meta data
- clear sequence button
- attenution bettween 0 and -1

-->
<script src=zzfx.js?1></script>
<script src=zzfxm.js?1></script>
<style>
body
{
    background:#111;
    color:#fff;
    user-select:none;
    white-space:nowrap;
    text-align:center;
}
button
{
    width:99px;
    margin:2px;
}
.heading
{
    font-size:29px;
}
.panel
{
    border-right:3px solid #999;
}
.panelRight, .panel
{
    padding:9px;
}
input
{
    background:#fff;
    border:0px;
    outline:2px solid #000;
}
.rowHighlight
{
    background:#bbf;
}
.rowHighlight2
{
    background:#ffb;
}
.pianoKey, .blackKey
{
    outline:2px solid #000;
    background:#fff;
    color:#000;
    width:200px;
    height:50px;
    line-height:50px;
    text-align:right;
    font-size:25px;
    font-family:arial;
    padding:4px;
}
.blackKey
{
    background:#000;
    color:#fff;
    width:120px;
    height:26px;
    line-height:26px;
    position:absolute;
    margin-top:-13;
}
.patternHeading
{
    outline:2px solid #000;
    color:#000;
}
.disabledPattern
{
    background:#999;
}
.loadingMessage
{
    font-size:7em;
    background:#000;
    z-index:100;
    position: fixed;
    left:0;
    top:30vh;
    width:100%;
    padding:20px;
    outline:9px solid #222;
    display:none;
}
a:hover, a:active , a:link {color:#05f;}
a:visited {color:#a5f;}
</style>

<div id=divBody style=display:none>
<div class=panel>
<div style=font-size:25px>ZzFXM Composer</div>
<br>Name <input id=inputName style=width:99px placeholder=Untitled>
<br>
<br>BPM <input id=inputBPM style=width:60px type=number min=60 max=360>
&nbsp;Loop <input id=inputLoop type=checkbox>
<br><br>
Volume <input type=range id=inputVolume>
<br>
<br>
Song <input type=radio name=radioSongOrPattern id=radioPlaySong checked>&nbsp;
Pattern <input type=radio name=radioSongOrPattern id=radioPlayPattern>

<br><button onclick=PlayMusic()>Play</button>
<button onclick=StopMusic()>Stop</button>
<br><button onclick=ButtonSave()>Save</button>
<button onclick=ButtonLoad()>Load</button>
<br><button onclick=ButtonShare()>Share</button>
<button onclick=ButtonExportWav()>Export Wav</button>
<br><button onclick=ButtonLoadDemo()>Load Demo</button>
<button onclick=ButtonReset()>Reset</button>

<hr>
Key <input type=number id=inputKey style=width:50 value=0 oninput=SetKey()>
&nbsp;Octave <input type=number id=inputOctave style=width:50 value=0 oninput=SetOctave()><br><br>
<div id=divPiano>
</div>

<p>Show Help <input type=checkbox onclick="divHelp.style.display=divHelp.style.display?'':'none'">
<div id=divHelp style=display:none>
<b>Pattern Controls</b>
<br>Keys = Play Note
<br>Up/Down = Note Volume
<br>Delete = Remove Note
<br>Enter = Stop Note
<br>Space = End Pattern
<p>
<b>Tips</b>
<br>Space Toggles Play
<br>Make instruments with <a href=https://killedbyapixel.github.io/ZzFX target=_blank>ZzFX</a>
</div>
</div>

<div class=panel>
<span class=heading>Sequence</span>
<p><div id=divSequencer style=display:grid></div>
</div>

<div class=panel>
<span class=heading>Patterns</span>
<br><br>
<div id=divPatternSettings></div>
<p><div id=divPattern style=display:grid></div>
</div>

<div class=panelRight>
<span class=heading>Instruments</span>
<p><div id=divInstruments style=display:grid;></div>
</div>
</div>

<div id=divLoadingMessage class=loadingMessage></div>
<a style=display:none id=linkSave></a>
<input type=file id=inputFile accept=.zzfxm style=display:none onchange=LoadFile(event)>
<script>

'use strict';

//////////////////////////////////////////////////////////////
// music settings

const maxInstruments = 32;
const maxChannels = 8;
const maxPatterns = 128;
const maxPatternLength = 128;
const maxSequenceLength = 128;
const defaultBPM = 125;
const defaultInstruments = 
[
    // melodic
    [1,0,130.81,,1],                                // 0 default
    [1.5,0,261.62,,.1,,1,1.5,,,,,,,,.1,.01],        // 1 piano
    [2,0,523.25,,0.25],                             // 2 lead   
    [,,261.62,.5,,.05,,,,,,,,1,,,.2],               // 3 air whistle   
    [1,0,65.4,,.07,.07,2,0,,,.5,.01],               // 4 bass
    [,0,65.4,,,0.7,2,0.41,,,,,,,,0.06],             // 5 bass 2
    [,0,65.4,,1,0,1,1.5,,,,,,,,3.6,,2],             // 6 wobbler
    
    // preccussion
    [,0,84,,,.1,,.7,,,,.5,,6.7,1,.05],              // 7 kick
    [,0,2200,,,0.04,3,2,,,800,0.02,,4.8,,0.01,0.1], // 8 hat
    [.8,0,2100,,,.3,3,3,,,-400,,,2],                // 9 hat 2
    [2,0,360,,,0.12,2,2,,,,,,9,,0.1],               // 10 clap
    [,0,130.81,.02,,1,,2,.5,.5,,,.01,,,,.2],        // 11 Gong
    
    // effects
    [,,1046.5,,,.05,,27,13,,,.3],                  // 12 squeek
    [,0,60,.05,,.06,3,.7,2,-24,,,,,,,.01],         // 13 zip
    [,0,1046.5,,.01,,1,,,,523.25,.03,,,,.09,.1],   // 14 blip 
    [,0,261.62,.01,1,,,,-32,,,,.01,,,.19,.01]      // 15 ya ya 
];

//////////////////////////////////////////////////////////////

let music;
let activeSound;
let activeMusicSound;
let activeSequence;
let activeInstrument;
let activePatternRow;
let activePatternColumn;
let wantsToPlay;
let wantsToExport;
let songSequence;
let songSequenceBPM;
let startTime;
let lastActiveSection;
let gain = zzfxX.createGain(); 

const Clamp = (a, max=1, min=0)=> a < min ? min : a > max ? max : a;
const Note = (semitoneOffset=12, root=440)=> root * 2**((semitoneOffset-12)/12);
const ArrayToString = e=> Array.isArray(e) ? '[' + e.map(e=>ArrayToString(e)).join(',') + ']': e;

function Update()
{
    requestAnimationFrame(Update);
    
    if (wantsToPlay-- == 1)
    {
        if (wantsToExport)
        {
            const filename = (inputName.value.trim() || 'zzfxm') + '.wav';
            const saveMusic = FormatMusic();

            linkSave.href = BuildWaveDataUrl(zzfxM(...saveMusic));
            linkSave.download = filename;
            linkSave.click();
        }
        else
        {
            const newMusic = FormatMusic(0);
           
            if (radioPlayPattern.checked)
            {
                // only play the active sequence
                newMusic[2][0] = newMusic[2][activeSequence] || [];
                newMusic[2].length = 1;
                
                // fix up song sequence to point to active sequence
                songSequence = GetSongSequence(...newMusic);
                songSequence = songSequence.map(e=>[activeSequence, e[1]]);
            }
            else
                songSequence = GetSongSequence(...newMusic);
            
            songSequenceBPM = inputBPM.value*1;
            activeMusicSound && activeMusicSound.stop();
            activeMusicSound = PlaySamplesArray(zzfxM(...UnconvertMusic(...newMusic)), inputLoop.checked);
            startTime = Date.now();
            
            if (activeMusicSound)
                DisableInputs();
        }
        
        divLoadingMessage.style.display = 'none';
        wantsToExport = wantsToPlay = 0;
    }
    
    gain.gain.value = inputVolume.value/100;
    
    if (lastActiveSection)
    {
        const s = document.getElementById(`sequenceRow${lastActiveSection[0]}`);
        s.style.background = '';

        const p = document.getElementById(`patternRow${lastActiveSection[1]}`);
        p.style.background = '';
        
        lastActiveSection = 0;
    }
    
    if (activeMusicSound)
    {
        const deltaTime = Date.now() - startTime;
        let i = songSequenceBPM * deltaTime / 1e3 / 60 * 4 | 0;
        
        if (inputLoop.checked)
            i = i % songSequence.length;
        
        const activeSection = songSequence[i];
        lastActiveSection = activeSection;
        
        if (activeSection)
        {
            SetActiveSequence(activeSection[0]);
            
            const s = document.getElementById(`sequenceRow${activeSection[0]}`);
            s.style.background = '#f00';

            const p = document.getElementById(`patternRow${activeSection[1]}`);
            p.style.background = '#f00';
        }
        else
        {
            DisableInputs(false);
            activeMusicSound = 0;
        }
    }
}
    
//////////////////////////////////////////////////////////////
// init

function Reset()
{
    // build empty song
    music = [[],[],[]];
    
    inputBPM.value = defaultBPM;
    inputName.value = '';
    inputLoop.checked = 0;
    inputVolume.value = 50;
    radioPlaySong.checked = 1;

    RebuildPiano();
    RebuildDisplay();
    SetActiveSequence(0);
    activeInstrument = 0;
    
    // load default instruments
    defaultInstruments.map((a,i)=>LoadInstrument(i, a));
    
    // stop sound
    StopMusic();
    activeSound && activeSound.stop();
}

function RebuildPiano()
{
    let outHTML = '';
    for(let i = 0; i < 12; ++i)
    {
        const note = 11 - i + inputKey.value*1 + inputOctave.value*12;
        const isWhite = '02479'.indexOf( i%12 - 1 ) < 0;
        outHTML += `<div id=pianoKey${i} onmousedown=PianoPress(${i}) class=${isWhite?'pianoKey':'blackKey'}>${
            note ? NoteName(note) : 'C-0'}</div>`;
    }
    
    divPiano.innerHTML = outHTML;
}

function RebuildDisplay()
{
    // sequencer
    let outHTML = '';
    for(let i = -1; i < maxSequenceLength; ++i)
    {
        if (i<0)
        {
            for(let j = 0; j < maxChannels+1; ++j)
                outHTML += `<div>${j ? j-1 : ''}</div>`;
        }
        else
        {
            outHTML += `<div id=sequenceRow${i}>${i}</div>`;
            for(let j = 0; j < maxChannels; ++j)
                outHTML += `<input id=inputSequence${i}_${j} ` +
                    `oninput=SetActiveSequence(${i});SaveLocalStorage() ` +
                    `onfocus=SetActiveSequence(${i});SaveLocalStorage() ` +
                    `type=number min=0 max=${maxPatterns} ` +
                    `class=${i%4?'#':'rowHighlight'}>`;
        }
    }
    divSequencer.innerHTML = outHTML;

    // sequencer grid
    divSequencer.style.gridTemplateColumns = '40px';
    for(let j = 0; j < maxChannels; ++j)
        divSequencer.style.gridTemplateColumns += ' 50px';

    // pattern
    outHTML = '';
    for(let i = -1; i < maxPatternLength+2; ++i)
    {
        if (i == -1)
        {
            for(let j = -1; j < maxChannels; ++j)
                outHTML += `<div id=divPatternID${j} ` +
                    `${j<0 ? '' : 'class=patternHeading'}>` +
                    `${j<0 ? 'Pat' : ''}</div>`;
        }
        else
        {
            if (i == 0) // instrument
            {
                outHTML += `<div>Inst</div>`;
                for(let j = 0; j < maxChannels; ++j)
                    outHTML += `<input id=inputPattern${i}_${j} ` +
                        `onfocus=PatternInstrumentEvent(event,${j}) ` +
                        `oninput=PatternInstrumentEvent(event,${j}) ` +
                        `class=rowHighlight2 ` +
                        `type=number min=0 max=${maxInstruments}>`;
            }
            else if (i == 1) // pan
            {
                outHTML += `<div>Pan</div>`;
                for(let j = 0; j < maxChannels; ++j)
                    outHTML += `<input id=inputPattern${i}_${j} ` +
                        `onfocus=PanEvent(event,${j}) ` +
                        `oninput=PanEvent(event,${j}) ` +
                        `class=rowHighlight2 ` +
                        `type=number min=-1 max=1 step=.1>`;
            }
            else // note
            {
                outHTML += `<div id=patternRow${i}>${i-2}</div>`;
                for(let j = 0; j < maxChannels; ++j)
                    outHTML += `<input readonly id=inputPattern${i}_${j} ` +
                        `onfocus=NoteEvent(event,${i-2},${j}) ` +
                        `onkeydown=NoteEvent(event,${i-2},${j}) ` +
                        `class=${(i-2)%4?'':'rowHighlight'}>`;
            }
        }
    }
    
    // pattern grid
    divPattern.innerHTML = outHTML;
    divPattern.style.gridTemplateColumns = '40px';
    for(let j = 0; j < maxChannels; ++j)
        divPattern.style.gridTemplateColumns += ' 50px';

    // instruments
    outHTML = '<div></div><div><a href=https://killedbyapixel.github.io/ZzFX target=_blank>ZzFX Sound Designer</a></div>';
    
    for(let i = 0; i < maxInstruments; ++i)
    {
        outHTML += `<div>${i}</div>`;
        outHTML += `<input id=inputInstrument${i} onfocus=InstrumentEvent(event,${i}) oninput=InstrumentEvent(event,${i})>`;
    }
    divInstruments.innerHTML = outHTML;
    divInstruments.style.gridTemplateColumns = '40px 200px';

    // display body
    divBody.style.display = 'flex';
}

function DisableInputs(disabled = true)
{
    // disable all
    for(let i = 0; i < maxSequenceLength; ++i)
    for(let j = 0; j < maxChannels; ++j)
    {
        const e = document.getElementById(`inputSequence${i}_${j}`);
        e.disabled = disabled;
    }
    for(let i = 0; i < maxPatternLength; ++i)
    for(let j = 0; j < maxChannels; ++j)
    {
        const e = document.getElementById(`inputPattern${i}_${j}`);
        e.disabled = disabled;
    }
}

///////////////////////////////////////////////////////////////////////////////
// buttons

function ButtonSave()
{
    const filename = (inputName.value.trim() || 'music') + '.zzfxm';
    const saveMusic = FormatMusic();
    const musicString = ArrayToString(saveMusic);
    
    linkSave.href = URL.createObjectURL(new Blob([musicString]));
    linkSave.download = filename;
    linkSave.click();
}

function ButtonLoad()
{
    inputFile.click();
}

function ButtonLoadDemo()
{
    if (confirm('Load demo and clear song data?'))
    {
        music = ConvertMusic(...demoSong);
        inputName.value = 'Demo';
        SaveLocalStorage();
        LoadLocalStorage();
    }
}

function ButtonReset()
{
    if (confirm('Reset and clear song data?'))
    {
        Reset();
        SaveLocalStorage();
    }
}

function ButtonShare()
{
    const crushed = JSONCrush(JSON.stringify(FormatMusic()));
    let search = '&name=' + encodeURIComponent(inputName.value.trim());
    search += '&crushed=' + crushed;
    
    const url = new URL(window.location.href);
    url.search = search;
    prompt('Share Url', url.toString());
}

function ButtonExportWav()
{
    wantsToExport = wantsToPlay = 2;
    divLoadingMessage.style.display = 'block';
    divLoadingMessage.innerHTML = 'Exporting';
}

///////////////////////////////////////////////////////////////////////////////
// input events

function SetActiveSequence(newAciveSequence)
{
    if (activeSequence != undefined)
        for(let j = 0; j < maxChannels; ++j)
        {
            const s = document.getElementById(`inputSequence${activeSequence}_${j}`);
            s.style.background = '';
            if (s.value.trim() != '')
                s.value = Clamp(s.value|0, maxInstruments);
        }
        
    activeSequence = newAciveSequence;
    
    music[2][activeSequence] = [];
    for(let j = 0; j < maxChannels; ++j)
    {
        const e = document.getElementById(`inputSequence${activeSequence}_${j}`);
        e.style.background = '#faa';
        
        music[2][activeSequence][j] = e.value == '' ? undefined : e.value | 0;
    }
    
    SetActivePatternNote();
    
    const patterns = music[2][activeSequence];
    for(let j = 0; j < maxChannels; ++j)
    {
        const e = document.getElementById(`divPatternID${j}`);
        const patternID = patterns[j];
        const hasPattern = patternID != undefined;
        
        if (hasPattern)
            music[1][patternID] = music[1][patternID] || [];
            
        const pattern = music[1][patternID];
        
        e.style.background = hasPattern ? '#faa' : '#633';
        e.innerHTML = hasPattern ? patternID : '&nbsp;';
        
        for(let i = 0; i < maxPatternLength+2; ++i)
        {
            const e = document.getElementById(`inputPattern${i}_${j}`);
                
            if (!hasPattern)
                e.value = '';
            else if (i < 2) // instrument & pan
                e.value = pattern[i] = pattern[i] || 0;
            else
                e.value = NoteName(pattern[i]);
            e.style.background = hasPattern ? '' : (i-2)%4? '#555' : '#335';
            if (!activeMusicSound)
                e.disabled = !hasPattern;
        }
    }
}

function SetKey()
{
    const key = Clamp(inputKey.value|0, 12);
    inputKey.value = key;
    
    RebuildPiano();
}

function SetOctave()
{
    const octave = Clamp(inputOctave.value|0, 9);
    inputOctave.value = octave;
    
    RebuildPiano();
}

function InstrumentEvent(e, instrument)
{
    LoadInstrument(instrument, StringToZzFX(e.target.value));
    PlayNote(instrument);
    
    activeInstrument = instrument;
    SaveLocalStorage();
}

function NoteEvent(e, beat, channel)
{
    if (e.repeat)
        return false;
        
    if (e.type == 'focus')
    {
        SetPatternValue(beat+2, channel);
        SetActivePatternNote(beat+2, channel);
        return false;
    }
        
    const patternID = music[2][activeSequence][channel];
    const oldNote = music[1][patternID][beat+2];
    
    let n;
    const note = PianoKey(e) + inputKey.value*1 + inputOctave.value*12 + 12;
    const value = 
        e.keyCode == 8  ?  0 :               // delete = clear
        e.keyCode == 13 ? -1 :               // enter = stop
        e.keyCode == 32 ? -2 :               // space = end
        e.keyCode == 38 || e.keyCode == 40 ? // up/down = volume
        (
            n = oldNote > 0 ? oldNote : 0,
            (n|0) + ((n*10%10 + 10 + (e.keyCode - 39)) / 10)%1
        ) :
        PianoKey(e) >= 0 ? note : // note
        -3; // no valid input

    if ((value > -3 || e.keyCode == 9) && e.keyCode != 38 && e.keyCode != 40)
    {
        // go to next
        const next = document.getElementById(`inputPattern${beat+3}_${channel}`);
        next && next.focus();
        e.preventDefault();
        SetActivePatternNote(beat+3, channel);
    }

    if (value > -3)
    {
        music[1][patternID][beat+2] = value;
    
        // set note value and input text
        e.target.value = NoteName(value);
        SetPatternValue(beat+2, channel);
    }
    
    return false;
}

function PatternInstrumentEvent(e, channel)
{
    const instrumentID = Clamp(e.target.value|0, maxInstruments);
    e.target.value = instrumentID;
    
    const patternID = music[2][activeSequence][channel];
    music[1][patternID][0] = instrumentID;
    
    SetPatternValue(0, channel);
    SetActivePatternNote(0, channel);
}

function PanEvent(e, channel)
{
    const pan = Clamp(e.target.value*1, 1, -1);
    e.target.value = pan;
    
    const patternID = music[2][activeSequence][channel];
    music[1][patternID][1] = pan;
    
    SetPatternValue(1, channel);
    SetActivePatternNote(1, channel);
}

function SetPatternValue(row, channel)
{
    // set input for all matching patterns
    // this handles the case when the same pattern is used more then once
    
    const patternID = music[2][activeSequence][channel];
    let value = music[1][patternID][row];
    let note = 12;
    let attenuation = 0;
    
    if (row > 1)
    {
        note = value | 0;
        attenuation = value % 1;
        value = NoteName(value);
    }
    
    const instrumentID = music[1][patternID][0];
    const pan = music[1][patternID][1];
    PlayNote(instrumentID, note, attenuation, pan);
    
    // set all matching patterns
    for(let j = 0; j < maxChannels; ++j)
    {
        if (j == channel)
            continue;
            
        const channelPatternID = music[2][activeSequence][j];
        if (channelPatternID != patternID)
            continue;
        
        const e = document.getElementById(`inputPattern${row}_${j}`);
        e.value = value;
    }
    
    SaveLocalStorage();
}
 
function SetActivePatternNote(row, column)
{
    if (activePatternRow != undefined || activePatternColumn != undefined)
    {
        const e = document.getElementById(`inputPattern${activePatternRow}_${activePatternColumn}`);
        e.style.background = '';
        activeInstrument = 0;
    }

    const patternID = music[2][activeSequence][column];
    activeInstrument = patternID != undefined ? music[1][patternID][0] : 0;
    activePatternRow = row;
    activePatternColumn = column;
    
    if (row == undefined || column == undefined)
        return;
        
    const e = document.getElementById(`inputPattern${row}_${column}`);
    e.style.background = '#5f5';
}

function LoadInstrument(instrument=0, zzfxParameters)
{
    const i = document.getElementById(`inputInstrument${instrument}`);
    if (!zzfxParameters || !zzfxParameters.length)
    {
        i.value = '';
        music[0][instrument] = undefined;
        return;
    }
    
    music[0][instrument] = zzfxParameters;
    
    let s = 'zzfx(...[';
    for(let j = 0; j < zzfxParameters.length; ++j)
    {
        const p = zzfxParameters[j];
        s += (j ? ',' : '') + (p == undefined ? '' : p);
    }
    i.value = s + '])';
}

function LoadFile(e)
{
    if (!e.target.files.length)
        return;

    const filename = e.target.files[0].name;
    const reader = new FileReader();
    reader.onload = e=>LoadString(e.target.result, filename.split('.')[0]);
    reader.readAsText(e.target.files[0]); 
}

function LoadString(string, name, validate = 1, convert = 1)
{
    RebuildDisplay();
    StopMusic();
    
    music = StringToMusic(string, validate);
    if (convert)
        music = ConvertMusic(...music);
    music[0].length = Clamp(music[0].length, maxInstruments);
    music[1].length = Clamp(music[1].length, maxPatterns);
    music[2].length = Clamp(music[2].length, maxSequenceLength);
    
    // add -2 to end of patterns
    music[1].map(p=>!p || p[p.length-1] == -2 || p.length<=2 || p.length == maxPatternLength || (p[p.length] = -2));
    
    // sequence
    for(let i = 0; i < music[2].length; ++i)
    for(let j = 0; j < maxChannels; ++j)
    {
        if (!music[2][i])
             music[2][i] = [];
    
        const patternID = music[2][i][j];
        const e = document.getElementById(`inputSequence${i}_${j}`);
        e.value = patternID == undefined ? '' : patternID || 0;
    }
    
    // instruments
    for(let i = 0; i < maxInstruments; ++i)
        LoadInstrument(i, music[0][i]);
        
    inputBPM.value = music[3] || defaultBPM;
    inputName.value = name;
    
    SetActiveSequence(0);
    SaveLocalStorage();
}

function PianoPress(key)
{
    const patternID = music[2][activeSequence][activePatternColumn];
        
    const k = document.getElementById(`pianoKey${key}`);
    const background = k.style.background;
    
    k.innerHTML;                     // force reset transition
    k.style.transition = '';         // unset transition
    k.style.background = '#f00';     // set key color red
    k.innerText;                     // force reset transition
    k.style.transition = '';         // unset transition
    k.style.transition = '.5s';      // set transition
    k.style.background = background; // set old background

    let note = 11 - key + inputKey.value*1 + inputOctave.value*12;
   
    if (activePatternRow <= 1 || patternID == undefined)
    {
        PlayNote(activeInstrument, note);
        return;
    }
        
    music[1][patternID][activePatternRow] = note;
    
    // set note value and input text
    const e = document.getElementById(`inputPattern${activePatternRow}_${activePatternColumn}`);
    e.value = NoteName(note);
    SetPatternValue(activePatternRow, activePatternColumn);
    SetActivePatternNote(Math.min(activePatternRow+1, maxPatternLength), activePatternColumn);
}

onkeydown = e=>
{
    if (e.keyCode == 38 || e.keyCode == 40)
        e.preventDefault();
    else if (e.keyCode == 32 && e.target.localName != 'input')
    {
        e.preventDefault();
        activeMusicSound ? StopMusic() : PlayMusic();
    }
}

///////////////////////////////////////////////////////////////////////////////
// Drag and Drop

ondrop = e=>
{
    if (e.dataTransfer.files.length)
    {
        const filename = e.dataTransfer.files[0].name;
        const reader = new FileReader();
        reader.onload = e=>LoadString(e.target.result, filename.split('.')[0]);
        reader.readAsText(e.dataTransfer.files[0]); 
    }

    return !1;
}

// prevent default drop events
ondragover = ()=> false;

///////////////////////////////////////////////////////////////////////////////
// local storage

function LoadLocalStorage()
{
    if (!localStorage.zzfxmMusic)
        return;
        
    LoadString(localStorage.zzfxmMusic, localStorage.zzfxmName, 0, 0);
    
    // get rid of search in url
    let url = new URL(window.location.href);
    url.search = '';
    window.history.pushState(null,null,url.toString())
}

function SaveLocalStorage()
{
    localStorage.zzfxmMusic = JSON.stringify(music);
    localStorage.zzfxmName = inputName.value;
}

///////////////////////////////////////////////////////////////////////////////
// sound stuff

function PlayMusic()
{
    SaveLocalStorage();
    divLoadingMessage.style.display = 'block';
    divLoadingMessage.innerHTML = 'Loading';
    wantsToPlay = 2;
}

function StopMusic()
{
    activeMusicSound && activeMusicSound.stop();
    songSequence = wantsToPlay = activeMusicSound = 0;
    DisableInputs(false);
}

function PlayNote(instrument=0, note=12, attenuation=0, pan=0)
{
    const zzfxParameters = music[0][instrument] || defaultInstruments[0];

    // set zzfx parameters
    const p = [...zzfxParameters];          // copy instrument
    p[0] = (p[0] || 1) * (1 - attenuation); // attenuation
    p[2] = Note(note, p[2]);                // frequency
        
    // stop old sound and play new one if valid
    activeSound && activeSound.stop();
    
    if (note > 0 || attenuation > 0 && note == 0)
        activeSound = PlaySamplesArray([zzfxG(...p)], 0, pan);
}

function PlayPatternNote(beat, channel, sequence = activeSequence)
{
    const patternID = music[2][sequence][channel];
    const value = music[1][patternID][beat+2];
    const instrument = music[1][patternID][0];
    const pan = music[1][patternID][1];
    PlayNote(instrument, value|0, value%1, pan);
}

// play array of audio sample data
function PlaySamplesArray(samplesArray, loop, pan=0)
{
    if (!samplesArray.length || !samplesArray[0].length)
        return;

    // create buffer and source
    let buffer = zzfxX.createBuffer(samplesArray.length, samplesArray[0].length, zzfxR),
        source = zzfxX.createBufferSource();

    // copy samples to buffer and play
    samplesArray.map((d,i)=> buffer.getChannelData(i).set(d));
    source.buffer = buffer;
    source.loop = !!loop;

    // create panner node
    const panner = zzfxX.createStereoPanner();
    panner.pan.value = pan;
    source.connect(panner).connect(gain);

    // connect and start
    gain.connect(zzfxX.destination);
    source.start();
    return source;
}

// convert a string to a music data array, will throw error if invalid
function StringToMusic(string, validate = 1)
{
    // check if safe to eval and get music data
    const music = string.replace(/null|[[\],\d\.-]/g, '') || eval(string.replace(/null/g, undefined)); 

    // try to generate music to check if valid
    return !validate || ValidateMusic(music) ? music : [[],[],[]];
};

function StringToZzFX(s)
{
    return s.slice(0,9) == 'zzfx(...[' ?
        s.slice(9).split(',').map( p=> p.length ? parseFloat(p) : undefined) : []; 
}

function NoteName(e)
{
    return e ? e > 0 ? 
    (e >= 1 ? 'CCDDEFFGGAAB'[e%12|0] +                 // note letter
              ('02579'.indexOf(e%12-1) >=0? '#':'') +  // natural or sharp
        ' ' + (e/12-1|0) + ' ' : '') +               // octave
    (e%1 ? '.' + (10 - e*10 % 10|0) : '') :           // volume
    e < -1 ? ' End' : 'Stop' : '';                     // special notes
}

function PianoKey(event)
{
    const k = 'ZSXDCVGBHNJM,L.;/Q2W3ER5T6Y7UI9O0P[=]'    // map key to note
        .indexOf(event.key && event.key.toUpperCase());  // find the key and check for invalid key
    return k < 0 ? 0 : k - 5 * (k > 16);                 // offset second row of 
};
  
function ValidateMusic(music)
{
    try { ValidateMusicInternal(...music); }
    catch(e) { return 0; }
    return 1;
}

function ValidateMusicInternal(instruments, patterns, sequence, BPM = defaultBPM)
{
  let instrumentParameters;
  let i;
  let j;
  let note;
  let sample;
  let patternChannel;
  let notFirstBeat;
  let stop;
  let instrument;
  let pitch;
  let attenuation;
  let sampleOffset;
  let nextSampleOffset;
  let sampleBuffer = [];
  let channelIndex = 0;
  let panning;
  let hasMore = 1;
  let sampleCache = {};

  // for each channel in order until there are no more
  for(; hasMore; channelIndex++) {

    // reset current values
    sampleBuffer = [hasMore = notFirstBeat = pitch = 0];

    // for each pattern in sequence
    sequence.map((patternIndex, sequenceIndex) => {
      // get pattern for current channel, use empty 1 note pattern if none found
      patternChannel = patterns[patternIndex][channelIndex] || [0, 0, 0];

      // check if there are more channels
      hasMore |= !!patterns[patternIndex][channelIndex];

      // for each beat in pattern, plus one extra if end of sequence
      for (i = 2; i < patternChannel.length + (sequenceIndex == sequence.length - 1); notFirstBeat = ++i) {

        // <channel-note>
        note = patternChannel[i];

        // stop if different instrument or new note
        stop = instrument != (patternChannel[0] || 0) | note | 0;

        // set up for next note
        if (note) {
          // set attenuation
          attenuation = note % 1;
          panning = patternChannel[1] || 0;
          if (note |= 0) {
            // get cached sample
            sampleBuffer = sampleCache[
              [
                instrument = patternChannel[sampleOffset = 0] || 0,
                note
              ]
            ] = sampleCache[[instrument, note]] || (
                // add sample to cache
                instrumentParameters = [...instruments[instrument]],
                instrumentParameters[2] *= 2 ** ((note - 12) / 12),
                zzfxG(...instrumentParameters)
            );
          }
        }
      }
    });
  }
}
    
function GetSongSequence(instruments, patterns, sequence, BPM = defaultBPM)
{
    let instrumentParameters, patternChannel, longestPattern, i, j=0,
        instrument, pitch, notFirstBeat, songSequence = [],
        channelIndex = 0, channelCount = sequence.reduce((a,b)=>Math.max(a, b.length), 0);

    // for each sequence of patterns
    sequence.map((sequencePatterns, sequenceIndex) =>
    {
        // get length of longest pattern channel
        longestPattern = sequencePatterns.reduce((a,b)=>Math.max(a, patterns[b].length), 0);

        // for each beat in pattern
        for (let i = 2; i < longestPattern; ++i)
            songSequence[j++] = [sequenceIndex, i];
    });
    
    return songSequence;
}

function BuildWaveDataUrl(samplesArray)
{
    // adapted from https://gist.github.com/asanoboy/3979747
    const channels = samplesArray.length;
    const length = channels * samplesArray[0].length;
    const buffer = new Int16Array(length + 23);
    const sampleRate = zzfxR;

    // wave header
    buffer[ 0] = 0x4952; // RI
    buffer[ 1] = 0x4646; // FF
    buffer[ 2] = (2*length + 15) & 0x0000ffff; // RIFF size
    buffer[ 3] = ((2*length + 15) & 0xffff0000) >> 16; // RIFF size
    buffer[ 4] = 0x4157; // WA
    buffer[ 5] = 0x4556; // VE
    buffer[ 6] = 0x6d66; // fm
    buffer[ 7] = 0x2074; // t
    buffer[ 8] = 0x0012; // fmt chunksize: 18
    buffer[ 9] = 0x0000; //
    buffer[10] = 0x0001; // format tag : 1 
    buffer[11] = channels; // channels: 2
    buffer[12] = sampleRate & 0x0000ffff; // sample per sec
    buffer[13] = (sampleRate & 0xffff0000) >> 16; // sample per sec
    buffer[14] = (2*channels*sampleRate) & 0x0000ffff; // byte per sec
    buffer[15] = ((2*channels*sampleRate) & 0xffff0000) >> 16; // byte per sec
    buffer[16] = 0x0004; // block align
    buffer[17] = 0x0010; // bit per sample
    buffer[18] = 0x0000; // cb size
    buffer[19] = 0x6164; // da
    buffer[20] = 0x6174; // ta
    buffer[21] = (2*length) & 0x0000ffff; // data size[byte]
    buffer[22] = ((2*length) & 0xffff0000) >> 16; // data size[byte]	

    // copy samples to buffer
    for (let i = 0; i < length; i++)
    for (let j = 0; j < channels; j++)
    {
        const s = samplesArray[j][i];
        buffer[i*2+j+23] = s>=1 ? (1<<15) - 1 : (s * (1<<15)|0);
    }

    // build the blob
    let eof = 0;
    let bufferNeedle = 0;
    const GetBuffer = (length) =>
    {
        eof = bufferNeedle + length >= buffer.length;
        const rt = new Int16Array(eof?buffer.length - bufferNeedle:length);
        for(let i=0; i<rt.length; i++)
            rt[i] = buffer[i+bufferNeedle];
        bufferNeedle += rt.length;
        return rt.buffer;
    }

    const blobData = [];
    while ( !eof ) { blobData.push(GetBuffer(1e3)); }
    const b = new Blob(blobData, {type:'audio/wav'});
    const URLObject = webkitURL || URL;
    return URLObject.createObjectURL(b);
}

/////////////////////////////////////////////////////////////////////////////
// conversion to and from internal format

// prepare music for saving
function FormatMusic(unconvert = 1)
{
    const newMusic = [[],[],[], inputBPM.value*1];
    
    // get sequence length
    for(let i = 0; i < music[2].length; ++i)
    for(let j = 0; j < maxChannels; ++j)
    {
        if (!music[2][i])
            music[2][i] = [];
    
        const pattern = music[2][i][j];
        if (pattern == undefined)
            continue;

        if (newMusic[2][i] == undefined)
            newMusic[2][i] = [];
        newMusic[2][i][j] = pattern;
    }
    
    // patterns
    let maxInstrument = 0;
    for(let i = 0; i < maxPatterns; ++i)
    {
        const pattern = music[1][i];
        if (!pattern)
            continue;

        const instrument = pattern[0] || 0;
        maxInstrument = Math.max(maxInstrument, instrument);
    
        let newPatternLength = 0;
        for(let j = 0; j < maxPatternLength+2; ++j)
        {
            let value = pattern[j];
            if (value == -2)
            {
                newPatternLength = j;
                break;
            }

            if (value != undefined)
                newPatternLength = j+1;

            if (newMusic[1][i] == undefined)
                newMusic[1][i] = [];
            newMusic[1][i][j] = value;
        }
        
        newMusic[1][i].length = newPatternLength;
    }
    
    // instruments
    for(let i = 0; i < maxInstrument+1; ++i)
    {
        const zzfxParameters = music[0][i] || defaultInstruments[0];
        newMusic[0][i] = zzfxParameters;
    }
    
    return unconvert ? UnconvertMusic(...newMusic) : newMusic;
}

// convert from zzfxm to internal format
const ConvertMusic = (instruments, patterns, sequence, BPM)=>
{
    const patternsNew = [], sequenceNew = [];

    for(const s of sequence)
    {
        const sequencePatterns = []
        for(const p of patterns[s])
        {
            // get pattern index, add if new
            const i = patternsNew.findIndex(a=>JSON.stringify(a)==JSON.stringify(p));
            sequencePatterns.push(i >= 0 ? i : patternsNew.push(p) - 1);
        }

        sequenceNew.push(sequencePatterns)
    }

    return [instruments, patternsNew, sequenceNew, BPM];
}

// convert from internal format to zzfxm
const UnconvertMusic = (instruments, patterns, sequence, BPM)=>
{
    let patternsNew = [], sequenceNew = [];
    
    // remove empty sequences
    sequence = sequence.filter(s=>s != undefined);

    for(const s of sequence)
    {
        const pattern = []
        for(const p of s)
            pattern.push(patterns[p]);
            
        // get pattern index, add if new
        const i = patternsNew.findIndex(a=>JSON.stringify(a)==JSON.stringify(pattern));
        sequenceNew.push(i >= 0 ? i : patternsNew.push(pattern) - 1);
    }

    return [instruments, patternsNew, sequenceNew, BPM];
}

// init and kick off first update
Reset();

// load
const url = new URL(window.location.href);
if (url.searchParams.has('crushed'))
{
    // uncrush
    const crushedString = url.searchParams.get('crushed');
    const musicString = JSONUncrush(crushedString);
    
    LoadString(musicString);
    if (url.searchParams.has('name'))
        inputName.value = url.searchParams.get('name');
    
    SaveLocalStorage();
}

LoadLocalStorage();
    
Update();

// test song [[[,0,219,,,,,1.1,,-.1,-50,-.05,-.01,1],[2,0,84,,,.1,,.7,,,,.5,,6.7,1,.05]],[[[0,-1,1,0,5,0],[1,1,8,8,0,3]]],[0,0,0,0],90]
    
const demoSong = [[[,0,77,,,.7,2,.41,,,,,,,,.06],[,0,43,.01,,.3,2,,,,,,,,,.02,.01],[,0,170,.003,,.008,,.97,-35,53,,,,,,.1],[.8,0,270,,,.12,3,1.65,-2,,,,,4.5,,.02],[,0,86,,,.1,,.7,,,,.5,,6.7,1,.05],[,0,41,,.05,.4,2,0,,,9,.01,,,,.08,.02],[,0,2200,,,.04,3,2,,,800,.02,,4.8,,.01,.1],[.3,0,16,,,.3,3]],[[[1,-1,21,21,33,21,21,33,21,21,33,21,21,33,21,21,33,33,21,21,33,21,21,33,21,21,33,21,21,33,21,21,33,33,21,21,33,21,21,33,21,21,33,21,21,33,21,21,33,33,21,21,33,21,21,33,21,21,33,21,21,33,21,21,33,33],[3,1,22,,,,,,,,,,,,,,,,,,,,,,,,,,,,24,,,,24,,,,,,,,,,,,,,,,,,,,,,,,22,,22,,22,,,,],[5,-1,21,,,,,,,,,,,,,,,,,,,,,,,,,,,,24,,,,23,,,,,,,,,,,,,,,,,,,,,,,,24,,23,,21,,,,],[,1,21,,,,,,,,,,,,,,,,,,,,,,,,,,,,24,,,,23,,,,,,,,,,,,,,,,,,,,,,,,24,,23,,21,,,,]],[[1,-1,21,21,33,21,21,33,21,21,33,21,21,33,21,21,33,33,21,21,33,21,21,33,21,21,33,21,21,33,21,21,33,33,21,21,33,21,21,33,21,21,33,21,21,33,21,21,33,33,21,21,33,21,21,33,21,21,33,21,21,33,21,21,33,33],[3,1,24,,,,,,,,27,,,,,,,,,,,,,,,,27,,,,24,,,,24,,,,,,,,27,,,,,,,,,,,,,,,,24,,24,,24,,,,],[5,-1,21,,,,,,,,,,,,,,,,,,,,,,,,,,,,24,,,,23,,,,,,,,,,,,,,,,,,,,,,,,24,,23,,21,,,,],[,1,21,,,,,,,,,,,,,,,,,,,,,,,,,,,,24,,,,23,,,,,,,,,,,,,,,,,,,,,,,,24,,23,,21,,,,],[6,1,,,34,34,34,,,,,,34,34,,,,,34,,,,34,34,,,,,34,,,,34,,,,34,34,34,,,,,,34,,,,,,34,34,,,34,34,,,,,,,,,34,34],[4,1,,,,,,,24,,,,,,24,,24,,,,24,,,,24,,,,,,,,,,,,,,,,24,,,,,,24,,24,,,,24,,,,24,,,,,,,,,,]],[[1,-1,21,21,33,21,21,33,21,21,33,21,21,33,21,21,33,33,21,21,33,21,21,33,21,21,33,21,21,33,21,21,33,33,23,23,35,23,23,36,23,23,35,23,23,36,23,23,35,35,23,23,35,23,23,35,23,23,36,23,23,35,23,23,36,36],[5,-1,21,,,19,,,21,,,,,,,,,,21,,,19,,,17,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,],[3,1,24,,,24,,,24,,,,,,,,,,24,,,24,,,24,,,,24.75,24.5,24.26,24.01,24.01,24.01,,,,,25,,,,,,,,25,,,,,,,,25,,,,,,,,25,25,25,25],[4,-1,,,,,,,,,,,,,,,,,,,,,,,,,,,24.75,24.5,24.26,24.01,24.01,24.01,24.01,24,,24,24,,24,24,24,24,,24,24,,24,,24,24,,24,24,,24,24,24,24,,24,24,,24,24],[7,-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,23,,21,23,,35,,23,,21,23,,35,,35,,23,,21,23,,35,,21,23,,35,,21,23,,,],[6,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,34,36,34,,33,34,34,36,31,36,34,,31,34,32,,33,36,34,,31,34,34,36,33,36,33,,31,,,]],[[1,-1,21,21,33,21,21,33,21,21,33,21,21,33,21,21,33,33,21,21,33,21,21,33,21,21,33,21,21,33,21,21,33,33,17,17,29,17,17,29,17,17,29,17,17,29,17,17,29,29,17,17,29,17,17,29,17,17,29,17,17,29,17,17,29,29],[4,1,24,24,,24,24,,24,24,24,24,,24,24,,24,,24,24,,24,24,,24,24,24,24,,24,24,,24,24,24,24,,24,24,,24,24,24,,,24,24,,24,,24,24,,24,24,,24,24,24,24,,24,24,,24,24],[7,-1,21,,19,21,,33,,21,,19,21,,33,,33,,21,,19,21,,33,,21,,19,21,,33,,33,,17,,17,17,29,17,17,29,17,,17,17,29,17,17,29,17,,17,17,29,17,17,29,17,,17,17,29,17,17,29],[2,1,,34,34,34,,34,34,34,,34,34,34,,34,34,34,,34,34,34,,34,34,34,,34,34,34,,34,,,,34,34,34,,34,34,34,,34,34,34,,34,34,34,,34,34,34,,34,34,34,,34,34,34,,34,,,],[6,1,,,36,,,,,,36,,36,,,,,,,,36,,,,,,36,,36,,,,,,,,36,,,,,,,,,,,,,,,,36,,,,,,36,,36,,,,,,],[3,1,,,,,25,,,,,,,,25,,,,,,,,25,,,,,,,,25,25,25,25,,,,,25,,,,,25,,,25,,,,,,,,25,,,,,,,,25,25,25,25]],[[1,-1,14,14,26,14,14,26,14,14,26,14,14,26,14,14,26,26,14,14,26,14,14,26,14,14,26,14,14,26,14,14,26,26,17,17,29,17,17,29,17,17,29,17,17,29,17,17,29,29,19,19,31,19,19,31,19,19,31,19,19,31,19,19,31,31],[4,1,24,24,,24,24,,24,24,24,24,,24,24,,24,,24,24,,24,24,,24,24,24,24,,24,24,,24,24,24,24,,24,24,,24,24,24,24,,24,24,,36,,24,24,,24,24,,24,24,24,24,,24,24,,24,24],[7,-1,14,,14,14,26,14,14,26,14,,14,14,26,14,14,26,14,,14,14,26,14,14,26,14,,14,14,26,14,14,26,17,,17,17,29,17,17,29,17,,17,17,29,17,17,29,19,,19,19,31,19,19,31,19,,19,19,31,19,19,31],[2,1,,36,36,36,,36,36,36,,36,36,36,,36,36,36,,36,36,36,,36,36,36,,36,36,36,,36,,,,36,36,36,,36,36,36,,36,36,36,,36,36,36,,36,36,36,,36,36,36,,36,36,36,,36,,,],[3,1,,,,,25,,,,,,,,25,,,,,,,,25,,,,,,,,25,25,25,25,,,,,25,,,,,,,,25,,,,,,,,25,,,,,,,,25,25,25,25],[6,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,34,,,,,,34,,34,,,,,,,,34,,,,,,34,,34,,,,,,]]],[0,1,1,2,3,4,4]];

// JSONCrush by Frank Force [MIT] https://github.com/KilledByAPixel/JSONCrush
function JSONCrush(e){let t=[];const n="-_.!~*'()";for(let e=127;--e;)(e>=48&&e<=57||e>=65&&e<=90||e>=97&&e<=122||n.includes(String.fromCharCode(e)))&&t.push(String.fromCharCode(e));for(let e=32;e<255;++e){let n=String.fromCharCode(e);"\\"==n||t.includes(n)||t.unshift(n)}const l=((e,t)=>{let n=t.length,l="";const r=e=>encodeURI(encodeURIComponent(e)).replace(/%../g,"i").length,o=e=>{let t=e.charCodeAt(0),n=e.charCodeAt(e.length-1);return t>=56320&&t<=57343||n>=55296&&n<=56319};let i={};for(let t=2;t<50;t++)for(let n=0;n<e.length-t;++n){let l=e.substr(n,t);if(i[l])continue;if(o(l))continue;let r=1;for(let o=e.indexOf(l,n+t);o>=0;++r)o=e.indexOf(l,o+t);r>1&&(i[l]=r)}for(;;){for(;n--&&e.includes(t[n]););if(n<0)break;let o,f=t[n],s=0,c=r(f);for(let e in i){let t=i[e],n=(t-1)*r(e)-(t+1)*c;l.length||(n-=r("")),n<=0?delete i[e]:n>s&&(o=e,s=n)}if(!o)break;e=e.split(o).join(f)+f+o,l=f+l;let u={};for(let t in i){let n=t.split(o).join(f),l=0;for(let t=e.indexOf(n);t>=0;++l)t=e.indexOf(n,t+n.length);l>1&&(u[n]=l)}i=u}return{a:e,b:l}})(e=JSONCrushSwap(e=e.replace(new RegExp("","g"),"")),t);let r=l.a;return l.b.length&&(r+=""+l.b),encodeURIComponent(r+'_')}function JSONUncrush(e){e=e.substring(0, e.length-1);const t=e.split("");let n=t[0];if(t.length>1){let e=t[1];for(let t of e){let e=n.split(t);n=e.join(e.pop())}}return JSONCrushSwap(n,0)}function JSONCrushSwap(e,t=1){const n=[['"',"'"],["':","!"],[",'","~"],["}",")","\\","\\"],["{","(","\\","\\"]],l=(e,t)=>{let n=new RegExp(`${(t[2]?t[2]:"")+t[0]}|${(t[3]?t[3]:"")+t[1]}`,"g");return e.replace(n,e=>e===t[0]?t[1]:t[0])};if(t)for(let t=0;t<n.length;++t)e=l(e,n[t]);else for(let t=n.length;t--;)e=l(e,n[t]);return e}

</script>
<a href="https://github.com/keithclark/ZzFXM" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#5AF; color:#222; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>